"""
这个题还是需要很多前置知识的。。。
首先要根据生成函数的式子推出 A_F(x) 的通项公式，然后要求A_F(x)是正整数且x为有理数，
由此问题转化为求解一个广义佩尔方程(Generalized Pell's equation)，然后要求广义佩尔方程通解的话你得先求出基本解，
求基本解需要使用LMM算法，而且广义的方程有多组基本解，对于每组基本解，都可以得到这组基本解递推出的其他所有解。
相当于所有的解是被每组基本解分组来分别递推出的。
求解广义佩尔方程需要借助预解式 u^2−d*v^2=1, 这是个普通佩尔方程只有一个基本解。

广义方程是根据预解式来递推的，同时由于预解式也可以看成广义佩尔方程，只不过等式右边为1，所以也可以套用
(x_0*u_n+d*y_0*v_n,x_0*v_n+u_n*y_0)来递推预解式每轮的 (u_n, v_n) 从而和广义方程的解一起迭代。

用LMM算法求出广义佩尔方程的三组基本解后再编程的话递推求解速度是非常快的

注意题目求的是A_F(x)也就是 n 而不是 x, 而且注意x=5*n+1的x是后面佩尔方程的x，和前面AF_x(x) 的自变量不是一回事。

https://pe.metaquant.org/pe137.html
ans = 1120149658760
"""

def main(N=15):
    arr = []
    x1,y1,x2,y2,x3,y3 = -1,1,1,1,4,2
    u,v = 9,4
    while True:
        x1,y1 = -u+5*v,-v+u
        x2,y2 = u+5*v,v+u
        x3,y3 = 4*u+10*v,4*v+2*u
        target = [(x-1)//5 for x in [x1,x2,x3] if (x-1)%5==0] # (x-1)%5 是因为推公式过程中用 x = 5*n+1 代换了
        # if(len(target)!=0): print(target, end = "\n\n")
        arr += target
        if len(arr) == N:
            # print(arr, end="\n\n")
            return arr[-1]
        else:
            u,v = 9*u+20*v,4*u+9*v

if __name__ == '__main__':
    print(main())