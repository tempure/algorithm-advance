#include <bits/stdc++.h>
using namespace std;
using ll = long long;

//2021 9.24 update

/*
这个生成函数展开成多项式的系数，可以用广义的二项式定理展开，是可以证明的

同样的，这个系数也可以用经典的排列组合方法得到，都是可以

经验来说，(1/(1-x))^n 的展开多项式，x^k 的系数是C(n+k-1, n-1)

本题还有一个细节就是要计算大整数取模，那就只能一位一位乘10然后取模
*/


//======================old content==========================

/*
推到出的生成函数f(x)=x * 1/((1-x)^4)
母问题:给出n种物品，每个物品无限个，求选出k个物品的方案数
用隔板法求出组合数系数为C(n+k-1, n-1), 母问题的生成函数为1/((1-x)^n)

所以对于此题的生成函数，f(x)的系数就是C(n+2,3)=(n+2)(n+1)n / 6

先算出n%p的值,对于高精度数取模，用秦九韶算法，从高位到低位：
假设已经算出前i位组成的数mod p的值为n，那么加上i+1位后的数 mod p
结果就是 (n * 10 + s[i+1]) % p
*/

const int N = 510, P = 10007;

char s[N];

void solve() {
    cin >> s;
    ll n = 0;
    for (int i = 0; s[i]; i++)
        n = (n * 10 + s[i] - '0') % P;
    cout << 1ll * n * (n + 1) * (n + 2) / 6 % P;
}

int main() {
    solve();
    return 0;
}