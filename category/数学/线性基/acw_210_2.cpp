#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 10010;

ll a[N];

/* 2021.9.30 update (线性代数忘光了.....)

本题的深入思考：
假设求出的线性基有k位，也就是对于所有给出的数的二进制表示上，可以找出k个数，
这些数的二进制表示能互补来让k个二进制位为1，当然我们也可以找不是基的元素来xor让某个二进制位为0

那么，我们所能表示的最大的排名的这个“排名”，就是 1 << k, 因为可以枚举每个二进制位是0还是1,如果超出这个最大，就是无解了

类比普通的加法运算的线性空间，我们可以用基表示出所有的元素，这些基向量的模是有大小关系的
同样放在xor的线性空间中，这些基向量的大小可以用二进制位的高低来比较，二进制位高的那个“1”，自然能在空间中
表示更大的向量，那么我们就可以由此考虑用二进制位的枚举01来“线性组合”这些基向量，由于这些基向量的xor能表示
最小到最大的所有元素，自然他们xor的结果也能覆盖所有题目给出元素的xor值域

假设题目要求第X大，那么直接把X二进制分解，这些二进制位是1就代表用该二进制位也为1的基向量元素，这样的基向量唯一
*/

//==============old code====================//

/*
比k小的非负整数有k个
先求出标准基，然后将K-1的二进制表示，表示后的每一位，就是所有基向量的系数
这里的表示都是左边是高位右边是低位的常规表示
基向量的顺序也是左边是1000.最大的基向量，那么系数相乘的结果，自然也是递减的，和二进制数k-1的增减性相同
最后乘上k-1二进制之后的系数异或即可

细节:如果不满秩，那么最小就可以取到0 如果满秩，那么异或就得不到0了
k-1表示二进制的系数，能求出前k-1小，加上0就是前k小
0~k-1恰好是k个，如果不能到0，那只能将k二进制表示了
*/

void solve() {
    int T;
    scanf("%d", &T);
    for (int C = 1; C <= T; C++) {
        printf("Case #%d:\n", C);
        int n; scanf("%d", &n);
        for (int i = 0; i < n ; i++) scanf("%lld", &a[i]);
        //高斯消元
        int k = 0;
        for (int i = 62; i >= 0; i--) {
            for (int j = k; j < n; j++)
                if (a[j] >> i & 1) {
                    swap(a[j], a[k]);
                    break;
                }
            if (!(a[k] >> i & 1)) continue;
            for (int j = 0; j < n; j++)
                if (j != k && (a[j] >> i & 1))
                    a[j] ^= a[k];
            k++;
            if (k == n) break;

        }
        //基是从第62位最高开始枚举的，注意题目范围1e18是小于2^63 - 1的
        reverse(a, a + k); //二进制系数从最低开始移位的所以要逆过来，也先用最小的基

        int m;
        scanf("%d", &m);
        while (m --) {
            ll x;
            scanf("%lld", &x);
            if (k < n) x --; //非满秩,就可以把0直接算上了，因为0必然可以xor得到,那么此时只需要求x-1大，因为基不能表示全0
            if (x >= (1ll << k))puts("-1"); //超出范围 无解
            else {
                ll res = 0;
                for (int i = 0; i < k; i++)
                    if (x >> i & 1)
                        res ^= a[i];
                printf("%lld\n", res);
            }
        }
    }
}

int main() {
    solve();
    return 0;
}